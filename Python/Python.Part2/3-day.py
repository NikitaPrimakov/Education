#####################################################
## День 3. Тема урока: тип данных bool              #
#####################################################

## Логический тип данных
#-----------------------


# Логический тип данных (булев тип, Boolean) — примитивный тип данных в информатике, 
# принимающий два возможных значения, иногда называемых истиной (True) и ложью (False). 
# Присутствует в подавляющем большинстве языков программирования как самостоятельная сущность или 
# реализуется через численный тип данных. В некоторых языках программирования за значение "истина" 
# принимается 1, за значение "ложь" — 0.

# Мы активно использовали логический тип данных, когда работали с флагами:

flag = False

                  
# или когда использовали условный оператор if-else:

a = 100
b = 17

if b > a:
  print('b больше a')
else:
  print('b не больше a')

                  
# Результатом логического выражения b > a является булево значение, в данном примере False, 
# так как значение в переменной b меньше значения в переменной a.

# Логические выражения можно использовать не только в условном операторе.

# Приведенный ниже код:

print(17 > 7)
print(17 == 7)
print(17 < 7)

                  
# выводит:

True
False
False

                  
# Логический тип данных – основа информатики.


## Булевы значения как числа
#---------------------------

# Мы можем также применять арифметические операции к логическим значениям.

# Приведенный ниже код:

print(True + True + True - False)
print(True + (False / True))

                  
# выводит:

3
1.0

                  
# Возможность трактовать булевы выражения как числа на практике используется не так часто. 
# Однако есть один прием, который может оказаться полезным. Поскольку True равно 1, а False равно 0, 
# сложение логических значений вместе – это быстрый способ подсчета количества значений True. 
# Это может пригодиться, когда требуется подсчитать количество элементов, удовлетворяющих условию.

# Приведенный ниже код:

numbers = [1, 2, 3, 4, 5, 8, 10, 12, 15, 17]
res = 0

for num in numbers:
    res += (num % 2 == 0)

print(res)

                  
# выводит количество четных элементов списка numbers, то есть число 5.


# Примечание 1. Вместо избыточного кода:
# if flag == True:

# программисты обычно пишут код:
# if flag:

                  
# Аналогично, вместо кода:
# if flag == False:
                
# программисты обычно пишут код:
# if not flag:

                  
# Примечание 2. Операторы and и or ленивые:
# при вычислении логического выражения x and y, если x == False, то результат всего выражения 
# x and y будет False, так что y не вычисляется;

# при вычислении логического выражения x or y, если x == True, то результат всего выражения x or y 
# будет True, и y не вычисляется.

# Примечание 3. 
# Математическая теория булевой логики определяет, что никакие другие операторы, 
# кроме not, and и or, не нужны. Все остальные операторы на двух входах могут быть указаны в 
# терминах этих трех операторов. Все операторы на трех или более входах могут быть указаны в 
# терминах операторов двух входов.

# Фактически, даже наличие пары or и and избыточно. Оператор and может быть определен в терминах 
# not и or, а оператор or может быть определен в терминах not и and. Однако and и or настолько 
# полезны, что во всех языках программирования есть и то, и другое.

# Примечание 4. Встроенные типы данных на английском языке.


## Функция isinstance()
#----------------------

# В языке Python имеется встроенная функция isinstance() для проверки соответствия типа объекта 
# какому-либо типу данных.

# Приведенный ниже код:

print(isinstance(3, int))
print(isinstance(3.5, float))
print(isinstance('Beegeek', str))
print(isinstance([1, 2, 3], list))
print(isinstance(True, bool))

                  
# выводит:

True
True
True
True
True

                  
# Число 3 – целое число, число 3.5 – вещественное число, 'Beegeek' – строка и так далее.

# Приведенный ниже код:

print(isinstance(3.5, int))
print(isinstance('Beegeek', float))

                  
# выводит:

False
False

# так как число 3.5 – не целое (float – не int), 'Beegeek' – строка, а не вещественное 
# число (str – не float).